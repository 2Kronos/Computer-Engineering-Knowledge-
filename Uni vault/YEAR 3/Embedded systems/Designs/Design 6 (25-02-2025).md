# 6.1 Experiment with mills() function

### **`millis()` Definition**  
**What it does**:  
Returns the number of milliseconds that have passed since the Arduino board was powered on or reset.  

**Key Characteristics**:  
- **Type**: `unsigned long` (non-negative, 32-bit number).  
- **Hardware-based**: Runs independently in the background.  

**Syntax**:  
```cpp 
unsigned long currentTime = millis(); // Returns elapsed time in ms 
```  

**Purpose**:  
Provides precise timing without pausing code execution (unlike `delay()`).  

**Example Use**:  
```cpp 
if (millis() - previousTime > 1000) {  
  // Action every 1 second  
  previousTime = millis();  
}  
```  

**TL;DR**:  
A non-blocking clock for tracking time in milliseconds. ⏱️

- Cant use precise value with this because it skips number best to use bigger/less than signs 

[Circuit design Design 6.1 - Tinkercad](https://www.tinkercad.com/things/kpAb7CrgImn-design-61/editel?returnTo=https%3A%2F%2Fwww.tinkercad.com%2Fdashboard%2Fdesigns%2Fcircuits)
# 6.2 Using Millis to switch on after the time as elapsed

https://www.tinkercad.com/things/hdsabCizgaF-design-62


# 6.3.1 Using modulus

https://www.tinkercad.com/things/lKIDhkCIZtz-design-631
**Detailed Concept Breakdown:**

1. **ELAPSED TIME**
    
    - `millis()` captures system uptime in milliseconds
        
    - `value1` stores and tracks progressive time measurements
        
    - Used to check when 1000ms threshold is crossed (`value1 >= 1000`)
        
2. **CONDITIONALS**
    
    - `if(value1 >= 1000)` creates time-based execution gate
        
    - Controls when the LED activates (digitalWrite)
        
    - Non-blocking check (unlike delay()) allowing continuous math operations
        
3. **ARITHMETIC OPERATIONS**
    
    - Division (`value1/value2`) calculates quotient
        
    - Modulus (`value1%value2`) calculates remainder
        
    - Results output via serial in formatted string
        
    - Demonstrates real-time math processing during program execution
        

**Key Program Flow:**

1. Tracks continuous time progression
    
2. Triggers LED at 1-second mark
    
3. Performs live division/modulus math
    
4. Streams all calculations to Serial Monitor
    
5. Maintains non-blocking execution throughout

# 6.3.2
https://www.tinkercad.com/things/4A2Abbpw89f-design-632
- Same as design 6.3.1 
- We just changed 
- This just show how you can keep to seperate counters
```c++
 result = result/value2 ;
to 
 result = result%value2 ;
```
# 6.4 One led goes high every second



# 6.5 Led increases in brightness 

# 6.6 Make the onboard LED go on and off 

# 6.7 Each one should increase in brightness out of phase

Increase the number of counts to be bigger than 255
- They start at a different intensity of brightness

```c++
 LED_brigthness(0, result,0);
   LED_brigthness(1, result,85);
  LED_brigthness(2, result,170);

}

void  LED_brigthness(int LED_NUM, int intensity, int phase){
	analogWrite(pinNum[LED_NUM], intensity);
  	intensity = intensity + phase;
}
```

- Here we add our intensity and then add the phase
		- The problem we face where is when our intensity is e.g 255 then the new intensity will be more than 255 
		- We need to keep around 255 
		- We use the same principle as the 360 value of a circile on a car