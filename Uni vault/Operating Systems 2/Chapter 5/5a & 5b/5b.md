# Semaphore

A semaphore is a synchronization tool used in operating systems to manage process coordination more efficiently than mutex locks. It's an integer variable that can only be accessed through two atomic operations: **wait()** and **signal()**.

- **wait(S)** checks if the semaphore value is less than or equal to 0, and if so, the process enters a busy wait. Otherwise, it decrements the semaphore value.
- **signal(S)** increments the semaphore value.

There are two types of semaphores:
- **Counting semaphore**: The value can be any integer.
- **Binary semaphore**: The value can only be 0 or 1, similar to a mutex lock.

Semaphores are useful for solving synchronization problems. For example, if process P1 must happen before P2, you can use a semaphore to synchronize their actions.

### Semaphore Implementation:
The semaphore operations must be executed atomically. This leads to a critical section problem, where both the `wait()` and `signal()` functions must be protected to ensure no two processes execute them simultaneously. Busy waiting can occur in this case, where processes keep checking the semaphore value in a loop.

### Implementation without Busy Waiting:
To avoid busy waiting, semaphores can maintain a waiting queue for processes. Each process that needs to wait is placed in the queue. Two operations are added:
- **block()**: Places a process in the waiting queue.
- **wakeup()**: Removes a process from the queue and places it in the ready queue to resume execution.

In this method, the semaphore's value determines whether a process enters the waiting queue or continues its execution, reducing the inefficiencies of busy waiting.


----
# Deadlock and starvation

- **Deadlock**:
  - Occurs when two or more processes are each waiting for an event that can only be triggered by one of the waiting processes.
  - Example:
    - Two semaphores S and Q are initialized to 1.
    - Process P0 waits on S and then Q, while Process P1 waits on Q and then S.
    - Both processes are stuck waiting for each other to release the required semaphore.

- **Starvation**:
  - Occurs when a process is indefinitely blocked and never gets the chance to execute because it remains stuck in the semaphore queue.

- **Priority Inversion**:
  - Happens when a lower-priority process holds a lock needed by a higher-priority process, delaying the higher-priority process.
  - This can be solved using a **priority-inheritance protocol**, where the priority of the low-priority process is temporarily raised to avoid blocking the high-priority one.

### Classical Problems of Synchronization:
- These problems are used to test new synchronization methods:
  - **Bounded-Buffer Problem**: Manages a fixed-size buffer shared between producers and consumers.
  - **Readers and Writers Problem**: Manages access to shared resources by multiple readers and writers.
  - **Dining-Philosophers Problem**: Simulates resource allocation among competing processes, often to demonstrate deadlock and synchronization issues.
Hereâ€™s a more understandable version in point form:
----

